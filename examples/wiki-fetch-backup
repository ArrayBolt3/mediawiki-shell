#!/bin/bash

missing_variable() {
   echo "$0: ERROR: missing variable '$1'!"
   exit 1
}

error_out_maybe() {
   if [ "$wiki_error_on_fetch" = "true" ]; then
      ## error out
      return 1
   else
      ## ignore error
      return 0
   fi
}

echo "$0: START"

set -e
cd ..

source common

## example:
#[[ -v SOURCE_WIKI_URL ]] || SOURCE_WIKI_URL='https://www.whonix.org/w'
#[[ -v wiki_backup_folder ]] || wiki_backup_folder="/tmp/whonix-wiki-backup"
#[[ -v wiki_article_must_include_sanity_test ]] || wiki_article_must_include_sanity_test="ZeroNet"

## These variables should be set by the calling script as environment variables.
[[ -v SOURCE_WIKI_URL ]] || missing_variable SOURCE_WIKI_URL
[[ -v wiki_backup_folder ]] || missing_variable wiki_backup_folder
[[ -v wiki_error_on_fetch ]] || wiki_error_on_fetch=true

[[ -v wiki_target_api ]] || wiki_target_api="${SOURCE_WIKI_URL}/api.php"

## https://www.mediawiki.org/wiki/Manual:Namespace
##
## NOTE to self by Patrick: also set by other script:
## wiki-backup-with-mediawiki-shell
## 500: site-specific
[[ -v wiki_namespace_list ]] || wiki_namespace_list="0 4 6 8 10 12 14"

allpages_file="${TMPFOLDER}/allpages.txt"
rm -f "$allpages_file"

echo "$0: INFO: TMPFOLDER         : $TMPFOLDER"
echo "$0: INFO: wiki_backup_folder: $wiki_backup_folder"
echo "$0: INFO: wiki_namespace_list: $wiki_namespace_list"
echo "$0: INFO: SOURCE_WIKI_URL: $SOURCE_WIKI_URL"
echo "$0: INFO: wiki_target_api: $wiki_target_api"

echo "$0: NOTE: wiki_namespace_list is site-specific."

if ! test -d "$wiki_backup_folder" ; then
   echo "$0: ERROR: wiki_backup_folder '$wiki_backup_folder' does not exist! Run...?:"
   echo "mkdir --parents '$wiki_backup_folder'"
fi

if ! test -w "$wiki_backup_folder" ; then
   echo "$0: ERROR: wiki_backup_folder '$wiki_backup_folder' unwriteable! Run...?:"
   echo "chown --recursive '$USER:$USER' '$wiki_backup_folder'"
fi

## Not required for public wiki.
#./login

for wiki_namespace_item in $wiki_namespace_list ; do
   echo "$0: INFO: wiki_namespace_item: $wiki_namespace_item"

   api_continue_or_not=""

   while true ; do
      all_pages=$(curl --fail --silent "${wiki_target_api}?action=query&format=json&list=allpages&aplimit=500&apnamespace=${wiki_namespace_item}&apcontinue=${api_continue_or_not}")

      #echo "$all_pages" | jq -r ".query.allpages[] | {title: .title}| .title"

      echo "$all_pages" | jq -r ".query.allpages[] | .title | @sh" | tee -a "$allpages_file" >/dev/null

      if ! api_continue_or_not=$(echo "$all_pages" | jq -r ".continue | .apcontinue") ; then
         break
      fi
      if [ "$api_continue_or_not" = "null" ]; then
         break
      fi
   done
done

test -f "$allpages_file"
result_test="$(cat "$allpages_file")"
counter_total="$(cat "$allpages_file" | wc -l)"
if [ "$result_test" = "" ]; then
   echo "$0 ERROR: result_test is empty!"
   exit 1
fi

if [ "$wiki_article_must_include_sanity_test" = "" ]; then
   echo "$0 INFO: wiki_article_must_include_sanity_test not configured, ok."
else
   if echo "$result_test" | grep -q -i "$wiki_article_must_include_sanity_test" ; then
      echo "$0 INFO: result_test does contain wiki_article_must_include_sanity_test '$wiki_article_must_include_sanity_test', ok. "
   else
      echo "$0 ERROR: See script source code. result_test does not contain '$wiki_article_must_include_sanity_test'! allpages_file: '$allpages_file'"
      echo ""
      echo "$0 result_test: '$result_test'"
      echo ""
      exit 1
   fi
fi

## Using the same format as git-mediawiki was initially useful during development
## to verify that this script produces the same backup result, i.e. is free of bugs.
## In the future it might allow for more backup restoration options.

echo "$0: $backup_page_item | $backup_filename_item"

counter_currently=0
while IFS=\n read -r item_from_all_pages ; do
   counter_currently=$(( $counter_currently + 1 ))

   backup_page_item="$item_from_all_pages"
   ## remove last letter ("'")
   backup_page_item="${backup_page_item::-1}"
   ## remove first letter ("'")
   backup_page_item="${backup_page_item:1}"

   search="'\''"
   replace="'"
   backup_page_item=$(echo "$backup_page_item" | str_replace "$search" "$replace")

   search="&"
   replace="%26"
   backup_page_item=$(echo "$backup_page_item" | str_replace "$search" "$replace")

   ## Same format as git-mediawiki: replace ' ' with '_'.
   ## Replace spaces with underscore.
   search=" "
   replace="_"
   backup_page_item=$(echo "$backup_page_item" | str_replace "$search" "$replace")

   backup_filename_item="$backup_page_item"

   ## Same format as git-mediawiki: replace '/' with '%2F'.
   ## Also the file system does not accept files containing '/'.
   search="/"
   replace="%2F"
   backup_filename_item=$(echo "$backup_filename_item" | str_replace "$search" "$replace")

   ## Same format as git-mediawiki: add '.mw' file extension.
   backup_filename_item="${backup_filename_item}.mw"
   echo "counter_currently / $counter_total | $backup_page_item | $backup_filename_item"

   WIKI_URL="$SOURCE_WIKI_URL" \
      ./fetch \
         "$backup_page_item" | \
         tee "${wiki_backup_folder}/${backup_filename_item}" \
         >/dev/null \
         || error_out_maybe

   ## Same format as git-mediawiki: add newline at the end.
   echo "" | tee -a "${wiki_backup_folder}/${backup_filename_item}" >/dev/null

done < "$allpages_file"
